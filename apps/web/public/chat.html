<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Chat Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }
    </style>
  </head>
  <body class="bg-gray-50 h-full">
    <div class="flex flex-col h-full">
      <!-- Header -->
      <div class="bg-blue-600 text-white p-3 font-semibold flex items-center justify-between">
        <div class="flex items-center space-x-2">
          <span>ðŸ¤–</span>
          <span>Chat Assistant</span>
        </div>
        <button
          id="logoutBtn"
          class="hidden text-sm bg-blue-700 hover:bg-blue-800 px-3 py-1 rounded"
        >
          Logout
        </button>
      </div>

      <!-- Messages (scrollable) -->
      <div id="chat" class="flex-1 p-3 overflow-y-auto space-y-2 bg-gray-50"></div>

      <!-- Typing indicator -->
      <div id="typing" class="px-3 py-2 text-sm text-gray-500 italic hidden">
        Bot is typing<span class="dot-1">.</span><span class="dot-2">.</span><span class="dot-3">.</span>
      </div>

      <!-- Input (always at bottom) -->
      <div class="p-2 border-t flex items-center space-x-2 bg-white">
        <input
          id="input"
          type="text"
          placeholder="Type a message..."
          class="flex-1 border rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          autocomplete="off"
        />
        <button
          id="send"
          class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
        >
          Send
        </button>
      </div>
    </div>

    <style>
      /* Animated typing dots */
      #typing span {
        opacity: 0;
        animation: blink 1.5s infinite;
      }
      #typing .dot-1 {
        animation-delay: 0s;
      }
      #typing .dot-2 {
        animation-delay: 0.3s;
      }
      #typing .dot-3 {
        animation-delay: 0.6s;
      }
      @keyframes blink {
        0%,
        80%,
        100% {
          opacity: 0;
        }
        40% {
          opacity: 1;
        }
      }

      .bot-bubble {
        word-break: break-word;
        overflow-wrap: anywhere;
        hyphens: auto;
      }
      .bot-bubble p + p { margin-top: 0.4rem; }
      .bot-bubble ul { list-style: disc; margin: 0.25rem 0 0.25rem 1.25rem; }
      .bot-bubble ol { list-style: decimal; margin: 0.25rem 0 0.25rem 1.25rem; }
    </style>

    <script>
      const chatDiv = document.getElementById("chat");
      const input = document.getElementById("input");
      const sendBtn = document.getElementById("send");
      const typingDiv = document.getElementById("typing");

      function addMessage(sender, text) {
        const wrapper = document.createElement("div");
        wrapper.className =
          sender === "You" ? "flex justify-end" : "flex justify-start";

        const bubble = document.createElement("div");
        bubble.className =
          (sender === "You"
            ? "bg-blue-600 text-white"
            : "bg-gray-200 text-gray-800") +
          " px-3 py-2 rounded-lg max-w-[85%]";
        if (sender === "Bot") {
          bubble.classList.add("bot-bubble");
          bubble.innerHTML = renderMarkdown(text);
        } else {
          bubble.textContent = text;
        }

        wrapper.appendChild(bubble);
        chatDiv.appendChild(wrapper);

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            chatDiv.scrollTop = chatDiv.scrollHeight;
          });
        });
      }

      let accessToken = null;
      let refreshToken = null;
      let isStandaloneMode = false;
      let isRefreshing = false;

      // Allowed parent origin (injected from server env var)
      const ALLOWED_ORIGIN = '__ENV_ALLOWED_ORIGIN__';

      // Check if running in iframe (embedded mode) or standalone
      const isInIframe = window.self !== window.top;

      // Refresh access token
      async function refreshAccessToken() {
        if (isRefreshing || !refreshToken) {
          return false;
        }

        isRefreshing = true;

        try {
          const response = await fetch('/auth/refresh', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ refreshToken }),
          });

          if (!response.ok) {
            throw new Error('Token refresh failed');
          }

          const data = await response.json();

          // Update tokens
          accessToken = data.accessToken;
          refreshToken = data.refreshToken || refreshToken;

          localStorage.setItem('accessToken', accessToken);
          if (data.refreshToken) {
            localStorage.setItem('refreshToken', data.refreshToken);
          }

          return true;
        } catch (error) {
          // Clear tokens and redirect to login
          localStorage.removeItem('accessToken');
          localStorage.removeItem('refreshToken');
          window.location.href = '/widget/login.html';
          return false;
        } finally {
          isRefreshing = false;
        }
      }

      // Initialize authentication
      function initAuth() {
        if (isInIframe) {
          // Embedded mode - wait for token from parent
          window.parent.postMessage("chat-ready", "*");

          window.addEventListener("message", (event) => {
            if (event.origin !== ALLOWED_ORIGIN) {
              return;
            }

            if (event.data?.type === "auth-token") {
              accessToken = event.data.token;
            }
          });
        } else {
          // Standalone mode - check localStorage
          isStandaloneMode = true;
          accessToken = localStorage.getItem('accessToken');
          refreshToken = localStorage.getItem('refreshToken');

          if (!accessToken) {
            // Redirect to login
            window.location.href = '/widget/login.html';
          } else {
            // Show logout button
            document.getElementById('logoutBtn').classList.remove('hidden');
          }
        }
      }

      // Logout handler
      document.getElementById('logoutBtn').addEventListener('click', () => {
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location.href = '/widget/login.html';
      });

      initAuth();

      let conversationId = null;
      let isLoading = false;

      async function sendMessage() {
        if (isLoading) return;

        if (!accessToken) {
          if (isStandaloneMode) {
            window.location.href = '/widget/login.html';
          } else {
            addMessage("Bot", "âš ï¸ Not authenticated.");
          }
          return;
        }

        const message = input.value.trim();
        if (!message) return;

        addMessage("You", message);
        input.value = "";

        // Show typing indicator
        typingDiv.classList.remove("hidden");
        setLoading(true);
        isLoading = true;

        try {
          let res = await fetch("/chat", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${accessToken}`
            },
            body: JSON.stringify({ message, conversationId }),
          });

          // If 401 and in standalone mode, try to refresh token
          if (res.status === 401 && isStandaloneMode) {
            const refreshed = await refreshAccessToken();
            if (refreshed) {
              // Retry the request with new token
              res = await fetch("/chat", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${accessToken}`
                },
                body: JSON.stringify({ message, conversationId }),
              });
            }
          }

          const data = await res.json();

          if (!res.ok) {
            throw new Error(data.error || 'Request failed');
          }

          // Check if server refreshed the token
          const newToken = res.headers.get('X-New-Token');
          if (newToken && isStandaloneMode) {
            accessToken = newToken;
            refreshToken = newToken;
            localStorage.setItem('accessToken', newToken);
            localStorage.setItem('refreshToken', newToken);
          }

          if (data.conversationId && !conversationId) {
            conversationId = data.conversationId;
          }

          // Hide typing indicator
          typingDiv.classList.add("hidden");
          setLoading(false);
          isLoading = false;

          addMessage("Bot", data.reply);
        } catch (err) {
          typingDiv.classList.add("hidden");
          setLoading(false);
          isLoading = false;

          // Check if it's an auth error
          if (err.message?.includes('401') || err.message?.includes('Unauthorized')) {
            if (isStandaloneMode) {
              localStorage.removeItem('accessToken');
              localStorage.removeItem('refreshToken');
              window.location.href = '/widget/login.html';
            } else {
              addMessage("Bot", "âš ï¸ Authentication failed. Please refresh.");
            }
          } else {
            addMessage("Bot", "âš ï¸ Error: Could not get response.");
          }
        }
      }

      function renderMarkdown(md) {
        const html = marked.parse(md, { breaks: true, gfm: true });
        return DOMPurify.sanitize(html);
      }

      function setLoading(isLoading) {
        const btn = document.getElementById("send");
        const input = document.getElementById("input");

        btn.disabled = isLoading;
        input.disabled = isLoading;

        if (isLoading) {
          btn.dataset.prevText = btn.textContent;
          btn.textContent = "Sendingâ€¦";
          btn.classList.add("opacity-60", "cursor-not-allowed");
        } else {
          btn.textContent = btn.dataset.prevText || "Send";
          btn.classList.remove("opacity-60", "cursor-not-allowed");
          input.focus();
        }
      }

      sendBtn.addEventListener("click", sendMessage);
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !isLoading) sendMessage();
        if (e.key === "Enter" && isLoading) e.preventDefault();
      });
    </script>
  </body>
</html>